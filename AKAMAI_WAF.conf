
# Product: Akamai WAF
# Category: WAF
# Supported Format: SYSLOG
# Reference: See below
# Last Updated: 2023-10-27
# Copyright 2023 Chronicle LLC
#
# Additional References:
#   This CBN covers 2 different log format:
#      - Akamai Kona web logs via Log Delivery Service (akamai_lds): for detailed understanding of log data, refer page#8 of https://www.netsurion.com/Corporate/media/Corporate/Files/Support-Docs/Integration-Guide-Akamai-WAF.pdf
#      - Akamai Kona web logs via SIEM API (akamai_siem): detailed information of log fields here: https://developer.akamai.com/api/cloud_security/siem/v1.html#event
#      - Akamai Logs ingested in CEF format: https://techdocs.akamai.com/siem-integration/docs/siem-cef-connector
filter {
  mutate {
    replace => {
      "principal_ip"                 => ""
      "target_url"                   => ""
      "network_application_protocol" => "DNS"
      "network_http_method"          => ""
      "network_http_response_code"   => ""
      "network_http_user_agent"      => ""
      "network_http_referral_url"    => ""
      "httpMessage.query"            => "" # akamai_siem
      "clientReputation"             => "" # akamai_siem
      "no_attackData" => "true"
      "attackData.clientIP" => ""
      "attackData.policyId" => ""
      "eventType.eventTypeName" => ""
      "type" => ""
      "version" => ""
      "geo.asn" => ""
      "eventId" => ""
      "eventType.eventDefinition.eventDescription" => ""
      "eventType.eventDefinition.eventName" => ""
      "eventType.eventDefinition.eventDefinitionId" => ""
      "eventType.eventTypeId" => ""
      "country" => ""
      "city" => ""
      "state" => ""
      "security_rules" => ""
      "useragent" => ""
      "cli_ip" => ""
      "securityRules" => ""
      "UA" => ""
      "cliIP" => ""
      "cp" => ""
      "reqId" => ""
      "rspContentType" => ""
      "proto" => ""
      "sr2" => ""
      "event.idm.read_only_udm.metadata.event_type" => ""
      "security_policy_id" => ""
      "non_deny_rules" => ""
      "deny_rule_format" => ""
      "reqHost" => ""
      "reqPort" => ""
      "reqPath" => ""
      "statusCode" => ""
      "reqMethod" => ""
      "bytes" => ""
      "p_ip" => ""
      "log_date" => ""
      "log_rule" => ""
      "log_description" => ""
      "httpMessage.host" => ""
      "message_copy" => ""
      "event_type" => ""
    }
  }

  if [message] =~ "CEF:0" {
    # Following intialization stanza would be used in cef_udm_mapping.include.
mutate {
  replace => {
    "src" => ""
    "dst" => ""
    "dvc" => ""
    "deviceTranslatedAddress" => ""
    "sourceTranslatedAddress" => ""
    "destinationTranslatedAddress" => ""
    "sourceTranslatedPort" => "0"
    "destinationTranslatedPort" => "0"
    "spt" => "0"
    "dpt" => "0"
    "in" => "0"
    "out" => "0"
    "fsize" => "0"
    "fname" => ""
    "fhash" => ""
    "oldFileSize" => "0"
    "deviceDirection" => ""
    "dtz" => ""
    "act" => ""
    "externalId" => ""
    "deviceExternalId" => ""
    "devicePayloadId" => ""
    "device_event_class_id" => ""
    "eventId" => ""
    "eventid" => ""
    "fileHash" => ""
    "categoryOutcome" => ""
    "event_name" => ""
    "cs2" => ""
    "cs5" => ""
    "cs7" => ""
    "rt" => ""
    "reason" => ""
    "shost" => ""
    "sntdom" => ""
    "sourceServiceName" => ""
    "spid" => ""
    "sproc" => ""
    "smac" => ""
    "suid" => ""
    "suser" => ""
    "dpid" => ""
    "dproc" => ""
    "dmac" => ""
    "dhost" => ""
    "duser" => ""
    "duid" => ""
    "shost_present" => "false"
    "temp_data" => ""
    "version" => ""
  }
}

grok {
  match => {
    "message" => [
                 "(?:<%{INT}>|%{DATA:temp_data})CEF:%{INT:version}\\|%{DATA:device_vendor}\\|%{DATA:device_product}\\|%{DATA:device_version}\\|%{DATA:device_event_class_id}\\|(?:%{DATA:event_name}\\||)(?P<severity>Medium|MEDIUM|Low|LOW|HIGH|High|Unknown|%{INT})(?:\\||)%{GREEDYDATA:cef_extension}"
                 ]
  }
  overwrite => ["version","device_event_class_id", "event_name","severity", "temp_data"]
  on_error => "not_grok_pattern"
}

if [not_grok_pattern] {
  drop {
    tag => "TAG_MALFORMED_ENCODING"
  }
}

mutate {
  gsub => ["cef_extension", "Customer Name=", "CustomerName="]
}

mutate {
  gsub => ["cef_extension", "Virus/Malware_Name", "Virus_Malware_Name"]
}

mutate {
  gsub => ["cef_extension", "Spyware/Grayware_Type", "Spyware_Grayware_Type"]
}

mutate {
  gsub => ["cef_extension", "(\\\s+)([0-9a-zA-Z_.-]+?)=", "^$2="]
}

kv {
  source => "cef_extension"
  field_split => "^"
  value_split => "="
  whitespace => "strict"
}

# CEF header and default extension fields are mapped to UDM using
# cef_udm_mapping.include.

    grok {
      match => {
        "src" => [
          "%{IP:src}"
        ]
      }
      overwrite => ["src"]
      on_error => "bad_src"
    }
    if [src] != "" {
      mutate {
        replace => {
          "event.idm.read_only_udm.metadata.event_type" => "NETWORK_HTTP"
        }
      }
    } else {
      mutate {
        replace => {
          "event.idm.read_only_udm.metadata.event_type" => "GENERIC_EVENT"
        }
      }
    }
    # Extraction of header and default extension fields is done using
# cef_extraction.include. Custom extension fields would be mapped in respective
# log type.

# Mostly, all the CEF fields are mapped to UDM in the most generalised way in
# this file. Still, this include file is optional for the users who wants to
# modify or override the UDM mapping written in this file.

# Parse timezone.

mutate {
  replace => {
    "parsed_timezone" => ""
    "principal_ip" => ""
    "target_ip" => ""
    "temp_dhost" => ""
    "temp_duser" => ""
    "temp_duid" => ""
  }
}
mutate {
  replace => {
    "principal_present" => "false"
    "principal_data_present" => "false"
    "target_present" => "false"
    "target_hostname_present" => "false"
  }
}
if [rt] != "" {
  grok {
    match => {
      "rt" => [
        "(?P<datetime>%{MONTH} %{MONTHDAY} %{TIME}) %{INT} %{WORD:parsed_timezone}"
        "(?P<datetime>%{MONTH} %{MONTHDAY} %{YEAR} %{TIME}) %{WORD:parsed_timezone}\\+%{GREEDYDATA}"
        "(?P<datetime>%{MONTH} %{MONTHDAY} %{YEAR} %{TIME})"
        "(?P<datetime>%{YEAR}-%{MONTHNUM}-%{MONTHDAY}T%{TIME}Z)"
        "(?P<datetime>%{MONTH} %{MONTHDAY} %{TIME})"
        "(?P<datetime>%{MONTH} %{MONTHDAY} %{TIME}) %{WORD:parsed_timezone}"
      ]
    }
    overwrite => ["parsed_timezone"]
    on_error => "invalid_datetime_format"
  }


  if [parsed_timezone] != "" && [dtz] == "" {
    mutate {
      replace => {
        "dtz" => "%{parsed_timezone}"
      }
    }
  }

  if ![invalid_datetime_format] and [dtz] != "" {
    mutate {
      rename => {
        "dtz" => "timezone"
      }
    }
    # Compute Timezone Offset if it's loaded by KVData
    if [timezone] != "" {
        if [timezone] =~ ".*GMT.*" {
            mutate {
                gsub => ["timezone", "GMT", "+0000"]
            }
        }
        else if [timezone] == "Z" {
            mutate {
                gsub => ["timezone", "Z", "+0000"]
            }
        }
        else if [timezone] =~ ".*UTC.*" {
            mutate {
                gsub => ["timezone", "UTC", "+0000"]
            }
        }
        else if [timezone] == "Europe/Paris" {
            mutate {
                gsub => ["timezone", "Europe/Paris", "+0100"]
            }
        }
        else if [timezone] =~ ".*CET.*" {
            mutate {
                gsub => ["timezone", "CET", "+0100"]
            }
        }
        else if [timezone] =~ ".*CEST.*" {
            mutate {
                gsub => ["timezone", "CEST", "+0200"]
            }
        }
        else if [timezone] =~ ".*MET.*" {
            mutate {
                gsub => ["timezone", "MET", "+0100"]
            }
        }
        else if [timezone] =~ ".*DST.*" {
            mutate {
                gsub => ["timezone", "DST", "+0100"]
            }
        }
        else if [timezone] =~ ".*AEDT.*" {
            mutate {
                gsub => ["timezone", "AEDT", "+1100"]
            }
        }
        else if [timezone] =~ ".*EDT.*" {
            mutate {
                gsub => ["timezone", "EDT", "-0400"]
            }
        }
        else if [timezone] =~ ".*EST.*" {
            mutate {
                gsub => ["timezone", "EST", "-0500"]
            }
        }
        else if [timezone] =~ ".*CST.*" {
            mutate {
                gsub => ["timezone", "CST", "-0600"]
            }
        }
        else if [timezone] =~ ".*CDT.*" {
            mutate {
                gsub => ["timezone", "CDT", "-0500"]
            }
        }
        else if [timezone] =~ ".*MST.*" {
            mutate {
                gsub => ["timezone", "MST", "-0700"]
            }
        }
        else if [timezone] =~ ".*MDT.*" {
            mutate {
                gsub => ["timezone", "MDT", "-0600"]
            }
        }
        else if [timezone] =~ ".*PST.*" {
            mutate {
                gsub => ["timezone", "PST", "-0800"]
            }
        }
        else if [timezone] =~ ".*PDT.*" {
            mutate {
                gsub => ["timezone", "PDT", "-0700"]
            }
        }
        else if [timezone] =~ ".*HST.*" {
            mutate {
                gsub => ["timezone", "HST", "-1000"]
            }
        }
        else if [timezone] =~ ".*RST.*" {
            mutate {
                gsub => ["timezone", "RST", "+0100"]
            }
        }
        else if [timezone] =~ ".*IST.*" {
            mutate {
                gsub => ["timezone", "IST", "+0530"]
            }
        }
    }

    if [timezone] != "" {
      mutate {
        replace => {
          "rt" => "%{datetime} %{timezone}"
        }
      }
    }
  }

  date {
    match => ["rt", "yyyy-MM-dd HH:mm:ss","MMM dd yyyy HH:mm:ss", "MMM dd yyyy HH:mm:ss Z", "MMM dd yyyy HH:mm:ss ZZ", "MM/dd/yyyy HH:mm:ss.SSS", "UNIX_MS"]
    on_error => "date_matching_failed"
  }

  if [date_matching_failed] {
    date {
      match => ["rt", "MMM dd HH:mm:ss Z", "MMM dd HH:mm:ss", "MMM  d yyyy HH:mm:ss", "MMM dd HH:mm:ss ZZZ", "MMM dd HH:mm:ss Z", "MMM dd HH:mm:ss", "UNIX_MS"]
      on_error => "date_matching_failed_again"
      rebase => true
    }
    if [date_matching_failed_again] {
      mutate {
        gsub => ["rt", "sourceDns", ""]
      }
      if [rt] =~ "(?i)utc" {
        mutate {
          gsub => ["rt", " UTC", ""]
        }
        date {
          match => ["rt", "MMM dd yyyy HH:mm:ss", "MMM dd yyyy HH:mm:ss"]
        }
      }
      mutate {
        gsub => ["rt", " ", ""]
      }
      date {
        match => ["rt", "yyyy-MM-ddTHH:mm:ssZ", "RFC3339", "ISO8601"]
        on_error => "timestamp_is_utc"
      }
    }
  }
}

mutate {
  uppercase => ["severity", "requestMethod"]
}

if [severity] in ["0", "1", "2", "3", "LOW"] {
  mutate {
    replace => {
      "security_result.severity" => "LOW"
    }
  }
}
else if [severity] in ["4", "5", "6", "MEDIUM"] {
  mutate {
    replace => {
      "security_result.severity" => "MEDIUM"
    }
  }
}
else if [severity] in ["7", "8", "HIGH"] {
  mutate {
    replace => {
      "security_result.severity" => "HIGH"
    }
  }
}
else if [severity] in ["9", "10", "VERY-HIGH"] {
  mutate {
    replace => {
      "security_result.severity" => "CRITICAL"
    }
  }
}

mutate {
  replace => {
    "app_protocol_src" => "%{app}"
  }
  on_error => "app_key_not_present"
}
if ![app_key_not_present] {
  # This file contains application protocol parsing logic

# Interface:
# app_protocol_src (required): string that contains application protocol or a port number
# app_protocol_output: string that is either empty or contains application
#                      protocol compatible to ApplicationProtocol enum in udm.proto

mutate {
  uppercase => [ "app_protocol_src" ]
}

if [app_protocol_src] in [ "22", "SSH", "SSHD" ] {
  mutate {
    replace => {
      "app_protocol_output" => "SSH"
    }
  }
}
else if [app_protocol_src] in [ "25", "SMTP" ] {
  mutate {
    replace => {
      "app_protocol_output" => "SMTP"
    }
  }
}
else if [app_protocol_src] in [ "53", "DNS" ] {
  mutate {
    replace => {
      "app_protocol_output" => "DNS"
    }
  }
}
else if [app_protocol_src] in [ "80", "8080", "HTTP" ] {
  mutate {
    replace => {
      "app_protocol_output" => "HTTP"
    }
  }
}
else if [app_protocol_src] in [ "443", "HTTPS" ] {
  mutate {
    replace => {
      "app_protocol_output" => "HTTPS"
    }
  }
}
else if [app_protocol_src] in [ "7400", "7401", "7402", "DDS" ] {
  mutate {
    replace => {
      "app_protocol_output" => "DDS"
    }
  }
}
else if [app_protocol_src] in [
  "UNKNOWN_APPLICATION_PROTOCOL", "AFP", "APPC", "AMQP", "ATOM", "BEEP", "BITCOIN",
  "BIT_TORRENT", "CFDP", "COAP", "DEVICE_NET", "DHCP", "E_DONKEY",
  "ENRP", "FAST_TRACK", "FINGER", "FREENET", "FTAM", "GOPHER", "HL7", "H323",
  "IRCP", "KADEMLIA", "LDAP", "LPD", "MIME", "MODBUS", "MQTT", "NETCONF",
  "NFS", "NIS", "NNTP", "NTCIP", "NTP", "OSCAR", "PNRP", "QUIC", "RDP", "RELP", "RIP",
  "RLOGIN", "RPC", "RTMP", "RTP", "RTPS", "RTSP", "SAP", "SDP", "SIP", "SLP", "SMB",
  "SNTP", "SSMS", "STYX", "TCAP", "TDS", "TOR", "TSP", "VTP", "WHOIS",
  "WEB_DAV", "X400", "X500", "XMPP"
] {
  mutate {
    replace => {
      "app_protocol_output" => "%{app_protocol_src}"
    }
  }

} else {
  mutate {
    replace => {
      "app_protocol_output" => ""
    }
  }
}

  if [app_protocol_output] != "" {
    mutate {
      replace => {
        "event.idm.read_only_udm.network.application_protocol" => "%{app_protocol_output}"
      }
    }
  }
}

mutate {
  uppercase => ["proto"]
}
mutate {
  replace => {
    "protocol_number_src" => "%{proto}"
  }
  on_error => "proto_key_not_present"
}

mutate {
  convert => {
    "protocol_number_src" => "integer"
  }
  on_error => "protocol_not_integer"
}

if ![proto_key_not_present] {
  # This file contains the ip protocol convertor
# Document:
#   - https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml

# Interface:
# protocol_number_src (required): number with the value which represents the protocol
# ip_protocol_out: string that is either empty or contains ip protocol
#                  compatible to IpProtocol enum in udm.proto

mutate {
  replace => {
    "ip_protocol_out" => "UNKNOWN_IP_PROTOCOL"
  }
}


if [protocol_number_src] in [ 1, "ICMP", "ICMPV6", 58 ] {
  mutate {
    replace => {
      "ip_protocol_out" => "ICMP"
    }
  }
} else if [protocol_number_src] in [ 2, "IGMP" ] {
  mutate {
    replace => {
      "ip_protocol_out" => "IGMP"
    }
  }
} else if [protocol_number_src] in [ 6, "TCP" ] {
  mutate {
    replace => {
      "ip_protocol_out" => "TCP"
    }
  }
} else if [protocol_number_src] in [ 17, "UDP" ] {
  mutate {
    replace => {
      "ip_protocol_out" => "UDP"
    }
  }
} else if [protocol_number_src] in [ 41, "IP6IN4" ] {
  mutate {
    replace => {
      "ip_protocol_out" => "IP6IN4"
    }
  }
} else if [protocol_number_src] in [ 47, "GRE" ] {
  mutate {
    replace => {
      "ip_protocol_out" => "GRE"
    }
  }
} else if [protocol_number_src] in [ 50, "ESP" ] {
  mutate {
    replace => {
      "ip_protocol_out" => "ESP"
    }
  }
} else if [protocol_number_src] in [ 88, "EIGRP" ] {
  mutate {
    replace => {
      "ip_protocol_out" => "EIGRP"
    }
  }
}  else if [protocol_number_src] in [ 97, "ETHERIP" ] {
  mutate {
    replace => {
      "ip_protocol_out" => "ETHERIP"
    }
  }
} else if [protocol_number_src] in [ 103, "PIM" ] {
  mutate {
    replace => {
      "ip_protocol_out" => "PIM"
    }
  }
} else if [protocol_number_src] in [ 112, "VRRP" ] {
  mutate {
    replace => {
      "ip_protocol_out" => "VRRP"
    }
  }
}

  if [ip_protocol_out] != "" {
    mutate {
      replace => {
        "event.idm.read_only_udm.network.ip_protocol" => "%{ip_protocol_out}"
      }
    }
  }
}

if [src] not in ["", "null", "None"] {
  mutate {
    replace => {
      "principal_ip" => "%{src}"
    }
    on_error => "src_not_set"
  }
  if ![src_not_set] {
    grok {
      match => {
        "principal_ip" => [ "%{IP:principal_ip}" ]
      }
      overwrite => ["principal_ip"]
      on_error => "principal_ip_failure"
    }

    if ![principal_ip_failure] {
      mutate {
        replace => {
          "principal_present" => "true"
        }
      }
      mutate {
        merge => {
          "event.idm.read_only_udm.principal.ip" => "principal_ip"
        }
        on_error => "principal_ip_not_set"
      }
    }
  }
}

if [dst] not in ["", "null"] {
  grok {
    match => {
      "dst" => [ "%{IP:dst_ip}" ]
    }
    overwrite => ["dst_ip"]
    on_error => "dst_ip_failure"
  }

  if ![dst_ip_failure] {
    mutate {
      replace => {
        "target_ip" => "%{dst_ip}"
      }
    }
    mutate {
      replace => {
        "target_present" => "true"
      }
    }
    mutate {
      merge => {
        "event.idm.read_only_udm.target.ip" => "dst_ip"
      }
    }
  }
}

if [sourceTranslatedAddress] != "" {
  mutate {
    replace => {
      "principal_data_present" => "true"
    }
  }
  mutate {
    merge => {
      "event.idm.read_only_udm.principal.nat_ip" => "sourceTranslatedAddress"
    }
  }
}

if [destinationTranslatedAddress] != "" {
  mutate {
    merge => {
      "event.idm.read_only_udm.target.nat_ip" => "destinationTranslatedAddress"
    }
  }
}

if [dvc] != "" {
  mutate {
    replace => {
      "dvc" => "{\"dvc\":[\"%{dvc}\"]}"
    }
  }
  mutate {
    gsub => ["dvc", ", ", "\",\""]
  }
  json {
    source => "dvc"
    array_function => "split_columns"
  }
  for ips in dvc {
    grok {
      match => {
        "ips" => "%{IP:ips}"
      }
      overwrite => ["ips"]
      on_error => "not_valid_ip"
    }
    if ![not_valid_ip] {
      mutate {
        merge => {
          "about.ip" => "ips"
        }
      }
    }
  }
}

if [deviceTranslatedAddress] != "" {
  mutate {
    merge => {
      "about.nat_ip" => "deviceTranslatedAddress"
    }
  }
}

if [deviceDirection] == "0" {
  mutate {
    replace => {
      "event.idm.read_only_udm.network.direction" => "INBOUND"
    }
  }
}
else if [deviceDirection] == "1" {
  mutate {
    replace => {
      "event.idm.read_only_udm.network.direction" => "OUTBOUND"
    }
  }
}

mutate {
  gsub => [
     "smac", "-", ":"
    ]
  lowercase => ["smac"]
}
if [smac] != "" {
  grok {
    match => {
      "smac" => "%{MAC:mac}"
    }
    on_error => "mac_not_present"
  }
  if ![mac_not_present] {
    mutate {
      replace => {
        "principal_data_present" => "true"
      }
    }
    mutate {
      merge => {
        "event.idm.read_only_udm.principal.mac" => "mac"
      }
    }
  }
}


mutate {
  gsub => [
    "dmac", "-", ":"
  ]
  lowercase => ["dmac"]
}
if [dmac] != "" {
  grok {
    match => {
      "dmac" => "%{MAC:mac_address}"
    }
    on_error => "dmac_not_present"
  }
  if ![dmac_not_present] {
    mutate {
      merge => {
        "event.idm.read_only_udm.target.mac" => "mac_address"
      }
    }
  }
}

mutate {
  gsub => [
     "dvcmac", "-", ":"
    ]
  lowercase => ["dvcmac"]
}
mutate {
  merge => {
    "about.mac" => "dvcmac"
  }
  on_error => "dvcmac_parsing_error"
}

mutate {
  replace => {
    "principal_role.name" => "%{spriv}"
  }
  on_error => "spriv_not_present"
}
if ![spriv_not_present] {
  mutate {
    merge => {
      "event.idm.read_only_udm.principal.user.attribute.roles" => "principal_role"
    }
    on_error => "role_field_not_present"
  }
  if ![role_field_not_present] {
    mutate {
      replace => {
        "principal_data_present" => "true"
      }
    }
  }
}

mutate {
  replace => {
    "target_role.name" => "%{dpriv}"
  }
  merge => {
    "event.idm.read_only_udm.target.user.attribute.roles" => "target_role"
  }
  on_error => "role_field_not_present"
}

mutate {
  replace => {
    "old_permissions.name" => "%{oldFilePermission}"
  }
  merge => {
    "event.idm.read_only_udm.src.resource.attribute.permissions" => "old_permissions"
  }
  on_error => "permissions_field_not_present"
}

mutate {
  replace => {
    "permissions.name" => "%{filePermission}"
  }
  merge => {
    "about.resource.attribute.permissions" => "permissions"
  }
  on_error => "permissions_field_not_present"
}

mutate {
  merge => {
    "security_result.category_details" => "cat"
  }
  on_error => "field_not_present"
}

# Need to map device_vendor, device_product and deviceExternalId fields to
# asset_id UDM field. Hence, added them as delimited values.
# Ref: https://g3doc.corp.google.com/company/teams/securitysales/ce_corner/chronicle/parsing/udm/udm_field_list_detailed.md?cl=head

if [deviceExternalId] != "" {
  mutate {
    replace => {
      "about.asset.asset_id" => "%{device_vendor}.%{device_product}:%{deviceExternalId}"
    }
    on_error => "fields_not_present"
  }
}

mutate {
  convert => {
    "fsize" => "uinteger"
    "oldFileSize" => "uinteger"
    "in" => "uinteger"
    "out" => "uinteger"
    "destinationTranslatedPort" => "integer"
  }
}
mutate {
  convert => {
    "dpt" => "integer"
  }
  on_error => "conv_failed"
}

if [act] == "accept" or [categoryOutcome] =~ "(/Success|Success)" or [cs2] =~ "Allow" {
  mutate {
    replace => {
      "_action" => "ALLOW"
    }
  }
  mutate {
    merge => {
      "security_result.action" => "_action"
    }
  }
} else if [act] == "deny" or [categoryOutcome] =~ "(/Failure|Failed)" or [cs2] =~ "Denied" {
  mutate {
    replace => {
      "_action" => "BLOCK"
    }
  }
  mutate {
    merge => {
      "security_result.action" => "_action"
    }
  }
}


grok {
  match => {
    "msg" => [
      "Bad Hash: (?P<_hash>[^\\s]+)"
    ]
  }
  overwrite => ["_hash"]
  on_error => "no_hash"
}

mutate {
  gsub => ["msg","^\\\"|\\\"$", ""]
}

mutate {
  rename => {
    "device_product" => "event.idm.read_only_udm.metadata.product_name"
    "device_version" => "event.idm.read_only_udm.metadata.product_version"
    "msg" => "event.idm.read_only_udm.metadata.description"
    "destinationServiceName" => "event.idm.read_only_udm.target.application"
    "dntdom" => "event.idm.read_only_udm.target.administrative_domain"
    "oldFilePath" => "event.idm.read_only_udm.src.file.full_path"
    "requestClientApplication" => "event.idm.read_only_udm.network.http.user_agent"
    "requestMethod" => "event.idm.read_only_udm.network.http.method"
    "filePath" => "about.file.full_path"
    "dvchost" => "about.hostname"
    "deviceNtDomain" => "about.administrative_domain"
    "dvcpid" => "about.process.pid"
    "deviceProcessName" => "about.process.command_line"
    "act" => "security_result.action_details"
    "externalId" => "event.idm.read_only_udm.metadata.product_log_id"
    "device_vendor" => "event.idm.read_only_udm.metadata.vendor_name"
    "_hash" => "about.file.sha256"
  }
}
mutate {
  replace => {
    "temp_dhost" => "%{dhost}"
  }
  on_error => "dhost_not_found"
}
mutate {
  replace => {
    "event.idm.read_only_udm.target.url" => "%{request}"
  }
  on_error => "request_not_found"
}

if [temp_dhost] != "" {
  mutate {
    replace => {
      "event.idm.read_only_udm.target.hostname" => "%{temp_dhost}"
      "target_present" => "true"
      "target_hostname_present" => "true"
    }
  }
}

mutate {
  replace => {
    "temp_duser" => "%{duser}"
  }
  on_error => "duser_not_found"
}
if [temp_duser] != "" {
  mutate {
    replace => {
      "event.idm.read_only_udm.target.user.user_display_name" => "%{temp_duser}"
    }
  }
}

mutate {
  replace => {
    "temp_duid" => "%{duid}"
  }
  on_error => "duid_not_found"
}
if [temp_duid] != "" {
  mutate {
    replace => {
      "event.idm.read_only_udm.target.user.userid" => "%{temp_duid}"
    }
  }
}

mutate {
  replace => {
    "event.idm.read_only_udm.principal.hostname" => "%{Device_name}"
  }
  on_error => "device_name_not_present"
}
if [device_name_not_present] {
  mutate {
    replace => {
      "event.idm.read_only_udm.principal.hostname" => "%{Enhetsnavn}"
    }
    on_error => "enhetsnavn_not_present"
  }
}

mutate {
  replace => {
    "sntdom" => "%{Domain}"
  }
  on_error => "domain_not_present"
}
if [domain_not_present] {
  mutate {
    replace => {
      "sntdom" => "%{Domene}"
    }
    on_error => "domene_not_present"
  }
}

mutate {
  replace => {
    "event.idm.read_only_udm.principal.group.group_display_name" => "%{Group_name}"
  }
  on_error => "group_name_not_present"
}
if [group_name_not_present] {
  mutate {
    replace => {
      "event.idm.read_only_udm.principal.group.group_display_name" => "%{Gruppenavn}"
    }
    on_error => "gruppenavn_not_present"
  }
}

mutate {
  replace => {
    "Received" => "%{Mottatt}"
  }
  on_error => "mottatt_not_present"
}

grok {
  match => {
    "Received" => ["%{GREEDYDATA:Received}\\+.*"]
  }
  overwrite => ["Received"]
  on_error => "different_Received_datetime_format"
}
if ![different_Received_datetime_format] {
  date {
    match => ["Received","yyyy-MM-ddTHH:mm:ss"]
    target => "event.idm.read_only_udm.metadata.collected_timestamp"
    on_error => "ReceivedDate_matching_failed"
  }
}

mutate {
  replace => {
    "Generated" => "%{Generert}"
  }
  on_error => "generert_not_present"
}

grok {
  match => {
    "Generated" => ["%{GREEDYDATA:Generated}\\+.*"]
  }
  overwrite => ["Generated"]
  on_error => "different_datetime_format"
}
if ![different_datetime_format] {
  date {
    match => ["Generated","yyyy-MM-ddTHH:mm:ss"]
    on_error => "GeneratedDate_matching_failed"
  }
}

mutate {
  replace => {
    "about.process.command_line" => "%{Subject}"
  }
  on_error => "subject_is_not_present"
}
if [subject_is_not_present] {
  mutate {
    replace => {
      "about.process.command_line" => "%{Emne}"
    }
    on_error => "emne_is_not_present"
  }
  if [emne_is_not_present] {
    mutate {
      replace => {
        "about.process.command_line" => "%{Path}"
      }
      on_error => "path_is_not_present"
    }
  }
}

mutate {
  replace => {
    "security_result.description" => "%{Type}"
  }
  on_error => "type_is_not_present"
}
if [type_is_not_present] {
  mutate {
    replace => {
      "security_result.description" => "%{Scan_Type}"
    }
    on_error => "scan_type_is_not_present"
  }
}

mutate {
  replace => {
    "event.idm.read_only_udm.target.user.userid" => "%{User}"
  }
  on_error => "user_is_not_present"
}
if [user_is_not_present] {
  mutate {
    replace => {
      "event.idm.read_only_udm.target.user.userid" => "%{Bruker}"
    }
    on_error => "bruker_is_not_present"
  }
}

mutate {
  gsub => ["CustomerName","\"",""]
}

mutate {
  replace => {
    "event.idm.read_only_udm.target.user.user_display_name" => "%{CustomerName}"
  }
  on_error => "customer_name_is_not_present"
}

mutate {
  replace => {
    "file_full_path" => ""
  }
}

mutate {
  replace => {
    "event.idm.read_only_udm.target.process.file.full_path" => "%{File_name}"
    "file_full_path" => "%{File_name}"
  }
  on_error => "file_name_is_not_present"
}
if [file_name_is_not_present] {
  mutate {
    replace => {
      "event.idm.read_only_udm.target.process.file.full_path" => "%{Object}"
      "file_full_path" => "%{Object}"
    }
    on_error => "object_is_not_present"
  }
  if [object_is_not_present] {
    mutate {
      replace => {
        "event.idm.read_only_udm.target.process.file.full_path" => "%{Objekt}"
        "file_full_path" => "%{Objekt}"
      }
      on_error => "objekt_is_not_present"
    }
    if [objekt_is_not_present] {
      mutate {
        replace => {
          "event.idm.read_only_udm.target.process.file.full_path" => "%{Infected_Resource}"
          "file_full_path" => "%{Infected_Resource}"
        }
        on_error => "infected_resource_not_present"
      }
    }
  }
}

if [file_full_path] != "" {
  mutate {
    replace => {
      "event.idm.read_only_udm.metadata.event_type" => "PROCESS_UNCATEGORIZED"
    }
  }
}

mutate {
  replace => {
    "security_result.action_details" => "%{Action_Taken}"
  }
  on_error => "action_taken_not_present"
}

mutate {
  replace => {
    "security_result.threat_name" => "%{Spyware}"
  }
  on_error => "spyware_not_present"
}
if [spyware_not_present] {
  mutate {
    replace => {
      "security_result.threat_name" => "%{Virus_Malware_Name}"
    }
    on_error => "virus_malware_not_present"
  }
  if ![virus_malware_not_present] {
    mutate {
      replace => {
        "security_result.threat_name" => "%{Unknown_Threat}"
      }
      on_error => "unknown_threat_not_present"
    }
  }
}

if [shost] != "" {
  grok {
    match => {
      "shost" => [
        "%{IP:ip}"
      ]
    }
    on_error => "not_ip"
  }
  if [not_ip] {
    mutate {
      rename => {
        "shost" => "event.idm.read_only_udm.principal.hostname"
      }
    }
  } else {
    mutate {
      replace => {
        "principal_present" => "true"
      }
    }
    mutate {
      merge => {
        "event.idm.read_only_udm.principal.ip" => "shost"
      }
    }
  }
  mutate {
    replace => {
      "shost_present" => "true"
    }
  }
}

if [sntdom] != "" {
  mutate {
    rename => {
      "sntdom" => "event.idm.read_only_udm.principal.administrative_domain"
    }
    replace => {
      "principal_data_present" => "true"
    }
  }
}

if [spt] != "" and [spt] != "0" {
  mutate {
    convert => {
      "spt" => "integer"
    }
  }
  mutate {
    rename => {
      "spt" => "event.idm.read_only_udm.principal.port"
    }
  }
}

if [sourceTranslatedPort] != "" and [sourceTranslatedPort] != "0" {
  mutate {
    convert => {
      "sourceTranslatedPort" => "integer"
    }
  }
  mutate {
    rename => {
      "sourceTranslatedPort" => "event.idm.read_only_udm.principal.nat_port"
    }
  }
}

if [sourceServiceName] != "" {
  mutate {
    rename => {
      "sourceServiceName" => "event.idm.read_only_udm.principal.application"
    }
    replace => {
      "principal_data_present" => "true"
    }
  }
}

if [spid] != "" {
  mutate {
    rename => {
      "spid" => "event.idm.read_only_udm.principal.process.pid"
    }
  }
}

if [sproc] != "" {
  mutate {
    rename => {
      "sproc" => "event.idm.read_only_udm.principal.process.command_line"
    }
    replace => {
      "principal_data_present" => "true"
    }
  }
}

if [suid] != "" {
  mutate {
    rename => {
      "suid" => "event.idm.read_only_udm.principal.user.userid"
    }
    replace => {
      "principal_data_present" => "true"
    }
  }
}

if [suser] != "" and [suser] !~ "^{" {
  mutate {
    rename => {
      "suser" => "event.idm.read_only_udm.principal.user.user_display_name"
    }
    replace => {
      "principal_data_present" => "true"
    }
  }
}

if [dpid] != "" {
  mutate {
    rename => {
      "dpid" => "event.idm.read_only_udm.target.process.pid"
    }
  }
}

if [dproc] != "" {
  mutate {
    rename => {
      "dproc" => "event.idm.read_only_udm.target.process.command_line"
    }
  }
}

if [reason] not in ["", " "] {
  mutate {
    rename => {
      "reason" => "security_result.summary"
    }
  }
}

if [oldFileSize] != 0 {
  mutate {
    rename => {
      "oldFileSize" => "event.idm.read_only_udm.src.file.size"
    }
  }
}
if [fsize] != 0 {
  mutate {
    rename => {
      "fsize" => "about.file.size"
    }
  }
}
if [dpt] != 0 and ![conv_failed] {
  mutate {
    rename => {
    "dpt" => "event.idm.read_only_udm.target.port"
    }
  }
}
if [destinationTranslatedPort] != 0 {
  mutate {
    rename => {
    "destinationTranslatedPort" => "event.idm.read_only_udm.target.nat_port"
    }
  }
}
if [in] != 0 {
  mutate {
    rename => {
    "in" => "event.idm.read_only_udm.network.received_bytes"
    }
  }
}
if [out] != 0 {
  mutate {
    rename => {
    "out" => "event.idm.read_only_udm.network.sent_bytes"
    }
  }
}

if [event_name] != "" and [device_event_class_id] != "" {
  mutate {
    replace => {
      "event.idm.read_only_udm.metadata.product_event_type" => "[%{device_event_class_id}] - %{event_name}"
    }
  }
} else if [device_event_class_id] != "" {
  mutate {
    replace => {
      "event.idm.read_only_udm.metadata.product_event_type" => "%{device_event_class_id}"
    }
  }
} else if [event_name] != "" {
  mutate {
    replace => {
      "event.idm.read_only_udm.metadata.product_event_type" => "%{event_name}"
    }
  }
}

if [event_name] in ["LogSpyware","LogPredictiveMachineLearning"] {
  mutate {
    replace => {
      "event.idm.read_only_udm.metadata.event_type" => "SCAN_UNCATEGORIZED"
    }
  }
}

grok {
  match => {
    "fileHash" => "(?P<_hash>^[0-9a-f]+$)"
  }
  on_error => "file_is_not_hash"
}

if [file_is_not_hash] and [fileHash] != "" {
  mutate {
    replace => {
      "about.file.full_path" => "%{fileHash}"
    }
  }
} else if [fileHash] != "" {
  mutate {
    rename => {
      "fileHash" => "about.file.sha256"
    }
  }
}

mutate {
  merge => {
    "event.idm.read_only_udm.about" => "about"
  }
  on_error => "merge_error"
}

mutate {
  replace => {
    "security_result.rule_name" => "%{mwProfile}"
  }
  on_error => "mwProfile_not_present"
}

mutate {
  replace => {
    "security_result.summary" => "%{appcategory}"
  }
  on_error => "appcategory_not_present"
}

mutate {
  replace => {
    "security_result.summary" => "%{Result}"
  }
  on_error => "result_not_present"
}

# Additional fields mapping
if [eventid] != "" {
  mutate {
    replace => {
      "eventId" => "%{eventid}"
    }
  }
}

if [eventId] != "" {
  mutate {
    replace => {
      "additional_eventId.key" => "eventId"
      "additional_eventId.value.string_value" => "%{eventId}"
    }
    on_error => "err_event_id_missing"
  }

  if ![err_event_id_missing] {
    mutate {
      merge => {
        "event.idm.read_only_udm.additional.fields" => "additional_eventId"
      }
      on_error => "err_event_id_field_missing"
    }
  }
}

if [devicePayloadId] != "" {
  mutate {
    replace => {
      "additional_devicePayloadId.key" => "devicePayloadId"
      "additional_devicePayloadId.value.string_value" => "%{devicePayloadId}"
    }
    on_error => "err_device_payload_id_missing"
  }

  if ![err_device_payload_id_missing] {
    mutate {
      merge => {
        "event.idm.read_only_udm.additional.fields" => "additional_devicePayloadId"
      }
      on_error => "err_device_payload_id_field_missing"
    }
  }
}

if [fname] != "" {
  mutate {
    replace => {
      "additional_fname.key" => "fname"
      "additional_fname.value.string_value" => "%{fname}"
    }
    on_error => "err_fname_missing"
  }

  if ![err_fname_missing] {
    mutate {
      merge => {
        "event.idm.read_only_udm.additional.fields" => "additional_fname"
      }
      on_error => "err_fname_field_missing"
    }
  }
}

# Custom field mapping

mutate {
  replace => {
    "additional_cs1.key" => "%{cs1Label}"
    "additional_cs1.value.string_value" => "%{cs1}"
  }
  on_error => "err_cs1_missing"
}

if ![err_cs1_missing] {
  mutate {
    merge => {
      "event.idm.read_only_udm.additional.fields" => "additional_cs1"
    }
    on_error => "err_cs1_field_missing"
  }
}

mutate {
  replace => {
    "additional_cs2.key" => "%{cs2Label}"
    "additional_cs2.value.string_value" => "%{cs2}"
  }
  on_error => "err_cs2_missing"
}

if ![err_cs2_missing] {
  mutate {
    merge => {
      "event.idm.read_only_udm.additional.fields" => "additional_cs2"
    }
    on_error => "err_cs2_field_missing"
  }
}

mutate {
  replace => {
    "additional_cs3.key" => "%{cs3Label}"
    "additional_cs3.value.string_value" => "%{cs3}"
  }
  on_error => "err_cs3_missing"
}

if ![err_cs3_missing] and [cs3] != "" {
  mutate {
    merge => {
      "event.idm.read_only_udm.additional.fields" => "additional_cs3"
    }
    on_error => "err_cs3_field_missing"
  }
}

mutate {
  replace => {
    "additional_cs4.key" => "%{cs4Label}"
    "additional_cs4.value.string_value" => "%{cs4}"
  }
  on_error => "err_cs4_missing"
}

if ![err_cs4_missing] {
  mutate {
    merge => {
      "event.idm.read_only_udm.additional.fields" => "additional_cs4"
    }
    on_error => "err_cs4_field_missing"
  }
}

if [cs5] != "" and [cs5] != "NA" {
  mutate {
    replace => {
      "additional_cs5.key" => "%{cs5Label}"
      "additional_cs5.value.string_value" => "%{cs5}"
    }
    on_error => "err_cs5_missing"
  }

  if ![err_cs5_missing] {
    mutate {
      merge => {
        "event.idm.read_only_udm.additional.fields" => "additional_cs5"
      }
      on_error => "err_cs5_field_missing"
    }
  }
}

mutate {
  replace => {
    "additional_cs6.key" => "%{cs6Label}"
    "additional_cs6.value.string_value" => "%{cs6}"
  }
  on_error => "err_cs6_missing"
}

if ![err_cs6_missing] and [cs6] != "" {
  mutate {
    merge => {
      "event.idm.read_only_udm.additional.fields" => "additional_cs6"
    }
    on_error => "err_cs6_field_missing"
  }
}

if [cs7] != "" {
  mutate {
    replace => {
      "additional_cs7.key" => "%{cs7Label}"
      "additional_cs7.value.string_value" => "%{cs7}"
    }
    on_error => "err_cs7_missing"
  }

  if ![err_cs7_missing] {
    mutate {
      merge => {
        "event.idm.read_only_udm.additional.fields" => "additional_cs7"
      }
      on_error => "err_cs7_field_missing"
    }
  }
}

mutate {
  replace => {
    "additional_flexString1.key" => "%{flexString1Label}"
    "additional_flexString1.value.string_value" => "%{flexString1}"
  }
  on_error => "err_flexString1_missing"
}

if ![err_flexString1_missing] {
  mutate {
    merge => {
      "event.idm.read_only_udm.additional.fields" => "additional_flexString1"
    }
    on_error => "err_flexString1_field_missing"
  }
}

mutate {
  replace => {
    "additional_cn1.key" => "%{cn1Label}"
    "additional_cn1.value.string_value" => "%{cn1}"
  }
  on_error => "err_cn1_missing"
}

if ![err_cn1_missing] {
  mutate {
    merge => {
      "event.idm.read_only_udm.additional.fields" => "additional_cn1"
    }
    on_error => "err_cn1_field_missing"
  }
}

mutate {
  replace => {
    "additional_cn2.key" => "%{cn2Label}"
    "additional_cn2.value.string_value" => "%{cn2}"
  }
  on_error => "err_cn2_missing"
}

if ![err_cn2_missing] {
  mutate {
    merge => {
      "event.idm.read_only_udm.additional.fields" => "additional_cn2"
    }
    on_error => "err_cn2_field_missing"
  }
}

mutate {
  replace => {
    "additional_cn3.key" => "%{cn3Label}"
    "additional_cn3.value.string_value" => "%{cn3}"
  }
  on_error => "err_cn3_missing"
}

if ![err_cn3_missing] {
  mutate {
    merge => {
      "event.idm.read_only_udm.additional.fields" => "additional_cn3"
    }
    on_error => "err_cn3_field_missing"
  }
}

mutate {
  replace => {
    "additional_cfp1.key" => "%{cfp1Label}"
    "additional_cfp1.value.string_value" => "%{cfp1}"
  }
  on_error => "err_cfp1_missing"
}

if ![err_cfp1_missing] {
  mutate {
    merge => {
      "event.idm.read_only_udm.additional.fields" => "additional_cfp1"
    }
    on_error => "err_cfp1_field_missing"
  }
}

mutate {
  replace => {
    "additional_cfp2.key" => "%{cfp2Label}"
    "additional_cfp2.value.string_value" => "%{cfp2}"
  }
  on_error => "err_cfp2_missing"
}

if ![err_cfp2_missing] {
  mutate {
    merge => {
      "event.idm.read_only_udm.additional.fields" => "additional_cfp2"
    }
    on_error => "err_cfp2_field_missing"
  }
}

mutate {
  replace => {
    "additional_cfp3.key" => "%{cfp3Label}"
    "additional_cfp3.value.string_value" => "%{cfp3}"
  }
  on_error => "err_cfp3_missing"
}

if ![err_cfp3_missing] {
  mutate {
    merge => {
      "event.idm.read_only_udm.additional.fields" => "additional_cfp3"
    }
    on_error => "err_cfp3_field_missing"
  }
}

mutate {
  replace => {
    "additional_cfp4.key" => "%{cfp4Label}"
    "additional_cfp4.value.string_value" => "%{cfp4}"
  }
  on_error => "err_cfp4_missing"
}

if ![err_cfp4_missing] {
  mutate {
    merge => {
      "event.idm.read_only_udm.additional.fields" => "additional_cfp4"
    }
    on_error => "err_cfp4_field_missing"
  }
}

mutate {
  replace => {
    "operation_label.value" => "%{Operation}"
    "operation_label.key" => "Operation"
  }
  on_error => "operation_not_present"
}
if ![operation_not_present] {
  if [operation_label][value] != "" {
    mutate {
      merge => {
        "security_result.detection_fields" => "operation_label"
      }
    }
  }
}

mutate {
  replace => {
    "operasjon_label.value" => "%{Operasjon}"
    "operasjon_label.key" => "Operasjon"
  }
  on_error => "operasjon_not_present"
}
if ![operasjon_not_present] {
  mutate {
    merge => {
      "security_result.detection_fields" => "operasjon_label"
    }
  }
}

mutate {
  replace => {
    "permission_label.value" => "%{Permission}"
    "permission_label.key" => "Permission"
  }
  on_error => "permission_not_present"
}
if ![permission_not_present] {
  mutate {
    merge => {
      "security_result.detection_fields" => "permission_label"
    }
  }
}

mutate {
  replace => {
    "tillatelse_label.value" => "%{Tillatelse}"
    "tillatelse_label.key" => "Tillatelse"
  }
  on_error => "tillatelse_not_present"
}
if ![tillatelse_not_present] {
  mutate {
    merge => {
      "security_result.detection_fields" => "tillatelse_label"
    }
  }
}

mutate {
  replace => {
    "infection_channel_label.value" => "%{Infection_Channel}"
    "infection_channel_label.key" => "Infection Channel"
  }
  on_error => "infection_channel_not_present"
}
if ![infection_channel_not_present] {
  mutate {
    merge => {
      "security_result.detection_fields" => "infection_channel_label"
    }
  }
}

mutate {
  replace => {
    "ipv6" => "%{IPv6_Address}"
  }
  on_error => "ipv6_not_present"
}

if ![ipv6_not_present] {
  if [ipv6] != "-" {
    mutate {
      merge => {
        "event.idm.read_only_udm.target.ip" => "IPv6_Address"
      }
    }
  }
}

mutate {
  replace => {
    "resource_Type_label.value" => "%{Resource_Type}"
    "resource_Type_label.key" => "Resource_Type"
  }
  on_error => "resource_type_not_present"
}
if ![resource_type_not_present] {
  mutate {
    merge => {
      "event.idm.read_only_udm.target.resource.attribute.labels" => "resource_Type_label"
    }
  }
}

mutate {
  replace => {
    "spyware_Grayware_Type_label.value" => "%{Spyware_Grayware_Type}"
    "spyware_Grayware_Type_label.key" => "Spyware/Grayware_Type"
  }
  on_error => "spyware_grayware_not_present"
}
if ![spyware_grayware_not_present] {
  mutate {
    merge => {
      "security_result.detection_fields" => "spyware_Grayware_Type_label"
    }
  }
}

mutate {
  replace => {
    "threat_probability_label.value" => "%{Threat_Probability}"
    "threat_probability_label.key" => "Threat_Probability"
  }
  on_error => "threat_probability_not_present"
}
if ![threat_probability_not_present] {
  mutate {
    merge => {
      "security_result.detection_fields" => "threat_probability_label"
    }
  }
}

mutate {
  merge => {
    "event.idm.read_only_udm.security_result" => "security_result"
  }
  on_error => "merge_error"
}

    if [app] != "" {
      mutate {
        replace => {
          "event.idm.read_only_udm.target.application" => "%{app}"
        }
      }
    }
    mutate {
      replace => {
        "event.idm.read_only_udm.principal.location.name" => "ASN %{AkamaiSiemASN}"
      }
      on_error => "asn_not_present"
    }
    mutate {
      replace => {
        "event.idm.read_only_udm.principal.location.city" => "%{AkamaiSiemCity}"
      }
      on_error => "city_not_present"
    }
    mutate {
      replace => {
        "event.idm.read_only_udm.principal.location.country_or_region" => "%{AkamaiSiemContinent}"
      }
      on_error => "country_not_present"
    }
    mutate {
      replace => {
        "event.idm.read_only_udm.network.session_id" => "%{devicePayloadId}"
      }
      on_error => "payload_not_present"
    }
    mutate {
      replace => {
        "request_header.key" => "AkamaiSiemRequestHeaders"
        "request_header.value.string_value" => "%{AkamaiSiemRequestHeaders}"
      }
      on_error => "request_header_not_present"
    }
    if ![request_header_not_present] {
      mutate {
        merge => {
          "event.idm.read_only_udm.additional.fields" => "request_header"
        }
      }
    }
    mutate {
      replace => {
        "response_header.key" => "AkamaiSiemResponseHeaders"
        "response_header.value.string_value" => "%{AkamaiSiemResponseHeaders}"
      }
      on_error => "response_header_not_present"
    }
    if ![response_header_not_present] {
      mutate {
        merge => {
          "event.idm.read_only_udm.additional.fields" => "response_header"
        }
      }
    }
    mutate {
      convert => {
        "AkamaiSiemResponseStatus" => "integer"
      }
      on_error => "conv_failed"
    }
    mutate {
      rename => {
        "AkamaiSiemResponseStatus" => "event.idm.read_only_udm.network.http.response_code"
      }
    }
    mutate {
      replace => {
        "siem_rule_tags" => "%{AkamaiSiemRuleTags}"
      }
      on_error => "rule_tags_not_present"
    }
    if ![rule_tags_not_present] {
      mutate {
        merge => {
          "security_result.category_details" => "AkamaiSiemRuleTags"
        }
      }
    }
    mutate {
      rename => {
        "AkamaiSiemTLSVersion" => "event.idm.read_only_udm.network.tls.version"
      }
    }
    mutate {
      replace => {
        "security_result.rule_id" => "%{cs1}"
      }
      on_error => "rule_id_not_present"
    }
    mutate {
      replace => {
        "security_result.threat_name" => "%{cs2}"
      }
      on_error => "threat_name_not_present"
    }
    mutate {
      replace => {
        "cs3_label.key" => "Rule Data"
        "cs3_label.value" => "%{cs3}"
      }
      on_error => "rule_data_not_present"
    }
    if![rule_data_not_present] {
      mutate {
        merge => {
          "security_result.detection_fields" => "cs3_label"
        }
      }
    }
    mutate {
      replace => {
        "flex_string2_label.key" => "%{flexString2Label}"
        "flex_string2_label.value" => "%{flexString2}"
      }
      on_error => "flex_string2_not_present"
    }
    if![flex_string2_not_present] {
      mutate {
        merge => {
          "security_result.detection_fields" => "flex_string2_label"
        }
      }
    }
    mutate {
      replace => {
        "flex_string1_label.key" => "%{flexString1Label}"
        "flex_string1_label.value" => "%{flexString1}"
      }
      on_error => "flex_string1_not_present"
    }
    if![flex_string1_not_present] {
      mutate {
        merge => {
          "security_result.detection_fields" => "flex_string1_label"
        }
      }
    }
  } else {
    # common metadata
    mutate {
      replace => {
        "event.idm.read_only_udm.metadata.vendor_name" => "Akamai"
        "event.idm.read_only_udm.metadata.product_name" => "Kona"
      }
    }
    grok {
      match => {
        "message" => [ "<%{INT}>%{DATA}:( %{IP:p_ip}:|) %{DATA:log_date}: %{DATA:log_rule}: %{GREEDYDATA:log_description}",
                      "%{INT:version} %{DATA:security_rules} %{DATA:country} %{DATA:state} %{DATA:city} %{IP:cli_ip} %{GREEDYDATA:useragent} %{INT:cp}"]
      }
      overwrite => ["useragent", "version", "state", "cli_ip" ,"city" ,"country" ,"security_rules" ,"cp", "log_description", "log_rule", "log_date", "p_ip"]
      on_error => "grok_failed"
    }
    if [grok_failed] {
      mutate {
        replace => {
          "event.idm.read_only_udm.metadata.event_type" => "NETWORK_HTTP"
          "event.idm.read_only_udm.network.application_protocol" => "HTTP"
          "event_type" => "NETWORK_HTTP"
        }
      }
      if !( [message] =~ /^\{/ ) {
        mutate {
          convert => {
            "no_attackData" => "boolean"
          }
        }
        # start akamai_lds
        grok {
          match => {
            "message" => [
              "%{IP:principal_ip} - - \\\[(?P<_ts>[^\]]+)\\\] \\\"(?:%{WORD:network_http_method} %{NOTSPACE:target_url}(?: HTTP/%{NUMBER:_httpversion})?|%{DATA:_rawrequest})\\\" %{NUMBER:network_http_response_code} (?:%{NUMBER:_irrelevant_bytes}|-) \\\"(?:-|%{NOTSPACE:network_http_referral_url})\\\" %{QUOTEDSTRING:network_http_user_agent} %{QUOTEDSTRING:_cookie} %{QUOTEDSTRING:_waf_policy} %{GREEDYDATA:_rem_msg}"
            ]
          }
          overwrite => ["principal_ip", "network_http_method", "target_url", "network_http_response_code","network_http_referral_url","network_http_user_agent" ]
          on_error => "not_grok_pattern"
        }
        grok {
          match => {
            "network_http_user_agent" => "\\\"%{DATA:network_http_user_agent}\\\""
          }
          overwrite => ["network_http_user_agent"]
        }
        date {
          match => ["_ts", "dd/MMM/yyyy:HH:mm:ss Z"]
        }
        mutate {
          convert => {
            "network_http_response_code" => "integer"
          }
        }
        mutate {
          uppercase => [ "network_http_method" ]
        }
        mutate {
          rename => {
            "network_http_response_code" => "event.idm.read_only_udm.network.http.response_code"
          }
          replace => {
            "event.idm.read_only_udm.network.http.method"          => "%{network_http_method}"
            "event.idm.read_only_udm.network.http.user_agent"      => "%{network_http_user_agent}"
            "event.idm.read_only_udm.network.http.referral_url"    => "%{network_http_referral_url}"
            "event.idm.read_only_udm.target.url"                   => "http:/%{target_url}"
            "event.idm.read_only_udm.metadata.product_version"     => "1.0"
            "event.idm.read_only_udm.metadata.product_event_type"  => "http"
          }
          merge => {
            "event.idm.read_only_udm.principal.ip" => "principal_ip"
          }
        }
      }
      else {
        # start akamai_siem
        # decode semicolon and equal charachter
        mutate { gsub => ["message","%3b","#;"] }
        mutate { gsub => ["message","%3d","="] }
        mutate {
          replace => {
            "message_copy" => "%{message}"
          }
        }
        # extract attackData: this part needs some gsub and we are going to
        # remove it from the original json in order to not affect the whole message
        grok {
          match => {
            "message" => [ ",\\s*\\\"attackData\\\":\\s*(?P<attackData>.+?\})," ]
          }
          overwrite => ["attackData"]
          on_error => "no_attackData"
        }
        if ![no_attackData] {
          mutate {
            gsub => ["message",",\\s*\\\"attackData\\\":.+?\},",","]
          }
        }
        # extract clientReputation if it exists: it countains semicolon charachters
        # that must not be replaced, so we are going to remove it from attackData
        grok {
          match => {
            "attackData" => [ ",\\s*\\\"clientReputation\\\":\\s*\\\"%{DATA:clientReputation}\\\"" ]
          }
          on_error => "_reputation_not_set"
          overwrite => ["clientReputation"]
        }
        if ![no_attackData] {
          mutate { gsub => ["attackData",",\\s*\\\"clientReputation\\\":\\s*\\\".*?\\\"",""] }
        # prepare multi value (semicolon separated) fields as array
        # in order to not  use csv filter which generates a non
        # iterable map. Arrays will be parsed by json filter
        mutate { gsub => ["attackData","rules\":\\s*(\".*?\")","rules\": \[$1\]"] }
        mutate { gsub => ["attackData","ruleVersions\":\\s*(\".*?\")","ruleVersions\": \[$1\]"] }
        mutate { gsub => ["attackData","ruleMessages\":\\s*(\".*?\")","ruleMessages\": \[$1\]"] }
        mutate { gsub => ["attackData","ruleTags\":\\s*(\".*?\")","ruleTags\": \[$1\]"] }
        mutate { gsub => ["attackData","ruleData\":\\s*(\".*?\")","ruleData\": \[$1\]"] }
        mutate { gsub => ["attackData","ruleSelectors\":\\s*(\".*?\")","ruleSelectors\": \[$1\]"] }
        mutate { gsub => ["attackData","ruleActions\":\\s*(\".*?\")","ruleActions\": \[$1\]"] }
        # replace semicolon with comma in attackData: arrays are ready to be parsed
        mutate { gsub => ["attackData","#;","\",\""] }
        }
        json {
          source => "message"
          array_function => "split_columns"
          on_error => "invalid_json"
        }
        if ![no_attackData]  and ![invalid_json] {
          json {
            source => "attackData"
            target => "attackData"
            array_function => "split_columns"
            # on_error => "not_json"
          }
          # date parsing
          date {
            match => [ "httpMessage.start","UNIX" ]
          }
        } else if [invalid_json] {
            mutate {
              replace => {
                "message" => "%{message_copy}"
              }
            }
            # extract attackData: this part needs some gsub and we are going to
            # remove it from the original json in order to not affect the whole message
            grok {
              match => {
                "message" => [ ",\\s*\\\"attackData\\\":\\s*(?P<attackData>.+?\]\})," ]
              }
              overwrite => ["attackData"]
              on_error => "no_attackData"
            }
            if ![no_attackData] {
              mutate {
                gsub => ["message",",\\s*\\\"attackData\\\":.+?\]\},",","]
              }
            }
            json {
              source => "message"
              array_function => "split_columns"
              on_error => "invalid_json"
            }
            mutate {
              replace => {
                "attackData" => "{\"attackData\":%{attackData}}"
              }
            }

            json {
              source => "attackData"
              array_function => "split_columns"
              on_error => "not_json"
            }
        }
        # UDM > Metadata
        mutate {
          replace => {
            "event.idm.read_only_udm.metadata.vendor_name" => "Akamai"
            "event.idm.read_only_udm.metadata.product_name" => "Kona"
            "event.idm.read_only_udm.metadata.event_type" => "NETWORK_HTTP"
          }
        }
        if [type] != "" {
          mutate {
            replace => {
              "event.idm.read_only_udm.metadata.product_event_type" => "%{type}"
            }
          }
        }
        if [version] != "" {
          mutate {
            replace => {
              "event.idm.read_only_udm.metadata.product_version" => "%{version}"
            }
          }
        }
        # UDM > Network
        grok {
          match => { "httpMessage.requestHeaders" => ["User-Agent%3a%20%{DATA:user_agent}%0d%0a"]}
          on_error => "_no_user_agent_set"
        }
        mutate {
          convert => {
            "httpMessage.status" => "integer"
          }
        }
        mutate {
          convert => {
            "httpMessage.bytes" => "uinteger"
          }
        }
        mutate {
          gsub => ["user_agent","#",""]
        }
        mutate {
          rename => {
            "httpMessage.method" => "event.idm.read_only_udm.network.http.method"
            "httpMessage.status" => "event.idm.read_only_udm.network.http.response_code"
            "user_agent" => "event.idm.read_only_udm.network.http.user_agent"
            "httpMessage.bytes" => "event.idm.read_only_udm.network.sent_bytes"
            "httpMessage.requestId" => "event.idm.read_only_udm.network.session_id"
            "httpMessage.tls" => "event.idm.read_only_udm.network.tls.version"
          }
      }
        # UDM > Target
        mutate {
          convert => {
            "httpMessage.port" => "integer"
          }
        }
        if [httpMessage][query] != "" {
          mutate {
            replace => {
              "httpMessage.path" => "%{httpMessage.path}?%{httpMessage.query}"
            }
          }
        }
        if [httpMessage][host] == "" and [event_type] == "NETWORK_HTTP" and [reqHost] == "" {
          mutate {
            replace => {
              "event.idm.read_only_udm.metadata.event_type" => "GENERIC_EVENT"
            }
          }
        }
        mutate {
          rename => {
            "httpMessage.host" => "event.idm.read_only_udm.target.hostname"
            "httpMessage.port" => "event.idm.read_only_udm.target.port"
            "httpMessage.path" => "event.idm.read_only_udm.target.url"
          }
        }
        if [reqHost] != "" {
          mutate {
            replace => {
              "event.idm.read_only_udm.target.hostname" => "%{reqHost}"
            }
          }
        }
        if [reqPort] != "" {
          mutate {
            convert => {
              "reqPort" => "integer"
            }
          }
          mutate {
            rename => {
              "reqPort" => "event.idm.read_only_udm.target.port"
            }
          }
        }
        if [reqPath] != "" {
          mutate {
            replace => {
              "event.idm.read_only_udm.target.url" => "%{reqPath}"
            }
          }
        }
        if [reqId] != "" {
          mutate {
            replace => {
              "event.idm.read_only_udm.network.session_id" => "%{reqId}"
            }
          }
        }
        if [statusCode] != "" {
          mutate {
            convert => {
              "statusCode" => "integer"
            } on_error => "fail"
          }
          mutate {
            rename => {
              "statusCode" => "event.idm.read_only_udm.network.http.response_code"
            }
          }
        }
        if [reqMethod] != "" {
          mutate {
            replace => {
              "event.idm.read_only_udm.network.http.method" => "%{reqMethod}"
            }
          }
        }
        if [UA] not in ["","-"] {
          mutate {
            replace => {
              "event.idm.read_only_udm.network.http.user_agent" => "%{UA}"
            }
          }
          if [reqHost] == "" {
            mutate {
              replace => {
                "event.idm.read_only_udm.metadata.event_type" => "STATUS_UPDATE"
              }
            }
          }
        }
        if [bytes] != "" {
          mutate {
            convert => {
              "bytes" => "uinteger"
            }
          }
          mutate {
            rename => {
              "bytes" => "event.idm.read_only_udm.network.sent_bytes"
            }
          }
        }

        # UDM > Principal
        if [attackData][clientIP] != "" {
          mutate {
            merge => {
              "event.idm.read_only_udm.principal.ip" => "attackData.clientIP"
            }
          }
        }
        mutate {
          rename => {
            "geo.country" => "event.idm.read_only_udm.principal.location.country_or_region"
            "geo.city" => "event.idm.read_only_udm.principal.location.city"
          }
        }
        if [geo][asn] != "" {
          mutate {
            replace => {
              "event.idm.read_only_udm.principal.location.name" => "ASN %{geo.asn}"
            }
          }
        }
        if [clientReputation] != "" {
          mutate {
            replace => {
              "rep_label.key" => "reputation"
              "rep_label.value" => "%{clientReputation}"
            }
          }
          mutate {
            merge => {
              "event.idm.read_only_udm.principal.labels" => "rep_label"
            }
          }
        }
        for i,rule in attackData.rules {
          mutate {
            replace => {
              "sr" => ""
            }
          }
          if [rule] != "" {
            base64 {
              source => "rule"
              target => "rule_string"
              on_error => "base64_rule_error"
            }
            if ![base64_rule_error] {
              mutate {
                replace => {
                  "sr.rule_id" => "%{rule_string}"
                }
              }
            } else {
              mutate {
                replace => {
                  "sr.rule_id" => "%{rule}"
                }
                on_error => "invalid_rule"
              }
              if [invalid_rule] {
                mutate {
                  replace => {
                    "rule_string" => "%{rule.id}"
                  }
                  on_error => "rule_id_not_present"
                }
                if ![rule_id_not_present] {
                  mutate {
                    replace => {
                      "sr.rule_id" => "%{rule_string}"
                    }
                    on_error => "invalid_rule_string"
                  }
                }
              }
            }
            for b,msg in attackData.ruleMessages {
              if [i] == [b] and [msg] != "" {
                base64 {
                  source => "msg"
                  target => "message_string"
                  on_error => "base64_message_error"
                }
                if ![base64_message_error] {
                  mutate {
                    replace => {
                      "sr.threat_name" => "%{message_string}"
                    }
                  }
                } else {
                  mutate {
                    replace => {
                      "sr.threat_name" => "%{msg}"
                    }
                  }
                }
              }
            }
            for a,action in attackData.ruleActions {
              if [i] == [a] and [action] != "" {
                base64 {
                  source => "action"
                  target => "action_string"
                  on_error => "base64_action_error"
                }
                if [base64_action_error] {
                  mutate {
                    replace => {
                      "action_string" => "%{action}"
                    }
                  }
                }
                if [action_string] =~ "deny" {
                  mutate {
                    replace => { "act" => "BLOCK" }
                  }
                } else if [action_string] in ["alert", "monitor", "allow", "tarpit"] {
                  mutate {
                    replace => { "act" => "ALLOW"}
                  }
                }
                mutate {
                  merge => { "sr.action" => "act" }
                  on_error => "_unknown_action"
                }
              }
            }
            for c,tag in attackData.ruleTags {
              if [i] == [c] and [tag] != "" {
                base64 {
                  source => "tag"
                  target => "tag_string"
                  on_error => "base64_tag_error"
                }
                if ![base64_tag_error] {
                  mutate {
                    merge => {
                      "sr.category_details" => "tag_string"
                    }
                  }
                } else {
                  mutate {
                    merge => {
                      "sr.category_details" => "tag"
                    }
                  }
                }
              }
            }
            for s,selector in attackData.ruleSelectors {
              if [i] == [s] and [selector] != "" {
                base64 {
                  source => "selector"
                  target => "selector_string"
                  on_error => "base64_selector_error"
                }
                mutate {
                  replace => { "labels" => "" }
                }
                if [base64_selector_error] {
                  mutate {
                    replace => {
                      "selector_string" => "%{selector}"
                    }
                  }
                }
                mutate {
                  replace => {
                    "labels.key" => "RuleSelector"
                    "labels.value" => "%{selector_string}"
                  }
                }
                mutate { merge => { "sr.detection_fields" => "labels" } }
              }
            }
            for d,data in attackData.ruleData {
              if [i] == [d] and [data] != "" {
                base64 {
                  source => "data"
                  target => "data_string"
                  on_error => "base64_data_error"
                }
                mutate {
                  replace => { "labels" => "" }
                }
                if [base64_data_error] {
                  mutate {
                    replace => {
                      "data_string" => "%{data}"
                    }
                  }
                }
                mutate {
                  replace => {
                    "labels.key" => "RuleData"
                    "labels.value" => "%{data_string}"
                  }
                }
                mutate { merge => { "sr.detection_fields" => "labels" } }
              }
            }
            if [sr] != "" {
              mutate {
                merge => {
                  "event.idm.read_only_udm.security_result" => "sr"
                }
              }
            }
          }
        }
        if [attackData][policyId] != "" {
          mutate {
            replace => {
              "sr2.summary" => "PolicyId:%{attackData.policyId}"
            }
          }
        } else if [proto] != "" {
          mutate {
            replace => {
              "sr2.summary" => "%{proto}"
            }
          }
        }

        if [securityRules] not in ["","-"] {
          csv {
            source => "securityRules"
            target => "csv_security_rules"
            separator => "|"
          }

          mutate {
            replace => {
              "security_policy_id" => "%{csv_security_rules.column1}"
              "non_deny_rules" => "%{csv_security_rules.column2}"
              "deny_rule_format" => "%{csv_security_rules.column3}"
            }
          }
        }

        if [security_policy_id] != "" {
          mutate {
            replace => {
              "sr2.rule_name" => "%{security_policy_id}"
            }
          }
        }

        if [non_deny_rules] != "" {
          mutate {
            replace => {
              "non_deny_rules_label.key" => "non_deny_rules"
              "non_deny_rules_label.value" => "%{non_deny_rules}"
            }
          }
          mutate {
            merge => {
              "sr2.about.resource.attribute.labels" => "non_deny_rules_label"
            }
          }
        }

        if [deny_rule_format] != "" {
          mutate {
            replace => {
              "deny_rule_format_label.key" => "deny_rule_format"
              "deny_rule_format_label.value" => "%{deny_rule_format}"
            }
          }
          mutate {
            merge => {
              "sr2.about.resource.attribute.labels" => "deny_rule_format_label"
            }
          }
        }

        if [sr2] != "" {
          mutate {
            merge => {
              "event.idm.read_only_udm.security_result" => "sr2"
            }
          }
        }
      }
      if [no_attackData] and [eventType][eventTypeName] != "" {
        mutate {
          replace => {
            "event.idm.read_only_udm.metadata.event_type" => "GENERIC_EVENT"
          }
        }
      }
    }
    if [message] =~ "eventData" {
      for evtdata in eventData {
        mutate {
          replace => {
            "eventData_label" => ""
          }
        }
        if [evtdata][key] != "" and [evtdata][value] != "" {
          mutate {
            replace => {
              "eventData_label.key" => "%{evtdata.key}"
              "eventData_label.value.string_value" => "%{evtdata.value}"
            }
          }
          mutate {
            merge => {
              "event.idm.read_only_udm.additional.fields" => "eventData_label"
            }
          }
        }
      }
    }
    if [eventId] != "" {
      mutate {
        replace => {
          "event.idm.read_only_udm.metadata.product_log_id" => "%{eventId}"
        }
      }
    }
    if [eventType][eventDefinition][eventDescription] != "" {
      mutate {
        replace => {
          "event.idm.read_only_udm.metadata.description" => "%{eventType.eventDefinition.eventDescription}"
        }
      }
    }
    if [eventType][eventDefinition][eventName] != "" {
      mutate {
        replace => {
          "event.idm.read_only_udm.metadata.product_event_type" => "%{eventType.eventDefinition.eventName}"
        }
      }
    }
    if [eventType][eventDefinition][eventDefinitionId] != "" {
      mutate {
        replace => {
          "event.idm.read_only_udm.target.resource.product_object_id" => "%{eventType.eventDefinition.eventDefinitionId}"
        }
      }
    }
    if [eventType][eventTypeId] != "" {
      mutate {
        replace => {
          "eventTypeId_label.key" => "eventTypeId"
          "eventTypeId_label.value.string_value" => "%{eventType.eventTypeId}"
        }
      }
      mutate {
        merge => {
          "event.idm.read_only_udm.additional.fields" => "eventTypeId_label"
        }
      }
    }
    if [eventType][eventTypeName] != "" {
      mutate {
        replace => {
          "eventTypeName_label.key" => "eventTypeName"
          "eventTypeName_label.value.string_value" => "%{eventType.eventTypeName}"
        }
      }
      mutate {
        merge => {
          "event.idm.read_only_udm.additional.fields" => "eventTypeName_label"
        }
      }
    }
    mutate {
      rename => {
        "tlsVersion" => "event.idm.read_only_udm.network.tls.version"
      }
    }
    if [useragent] != "" {
      mutate {
        rename => {
          "useragent" => "event.idm.read_only_udm.network.http.user_agent"
        }
      }
      mutate {
        replace => {
          "event.idm.read_only_udm.network.application_protocol" => "HTTP"
        }
      }
    }
    if [cli_ip] != "" {
      mutate {
        merge => {
          "event.idm.read_only_udm.principal.ip" => "cli_ip"
        }
      }
    }
    if [country] != "" {
      mutate {
        rename => {
          "country" => "event.idm.read_only_udm.principal.location.country_or_region"
        }
      }
    }
    if [city] != "" {
      mutate {
        rename => {
          "city" => "event.idm.read_only_udm.principal.location.city"
        }
      }
    }
    if [state] != "" {
      mutate {
        gsub => ["state","%[0-9]+"," "]
      }
      mutate {
        replace => {
          "event.idm.read_only_udm.principal.location.state" => "%{state}"
        }
      }
    }
    if [security_rules] != "" {
      mutate {
      gsub => ["security_rules","\\\||",""]
      }
      mutate {
        replace => {
          "sec_res.rule_name" => "%{security_rules}"
        }
      }
      mutate {
        merge => {
          "event.idm.read_only_udm.security_result" => "sec_res"
        }
      }
    }
    if [cli_ip] != "" {
      mutate {
        replace => {
          "event.idm.read_only_udm.metadata.event_type" => "STATUS_UPDATE"
        }
      }
    }

    if [cliIP] != "" {
      mutate {
        merge => {
          "event.idm.read_only_udm.principal.ip" => "cliIP"
        }
      }
    } else if [p_ip] != "" {
      mutate {
        merge => {
          "event.idm.read_only_udm.principal.ip" => "p_ip"
        }
      }
      mutate {
        replace => {
          "event.idm.read_only_udm.metadata.event_type" => "STATUS_UPDATE"
        }
      }
    }

    if [log_description] != "" {
      mutate {
        replace => {
          "event.idm.read_only_udm.metadata.description" => "%{log_description}"
        }
      }
    }

    if [log_rule] != "" {
      mutate {
        replace => {
          "security_result.rule_name" => "%{log_rule}"
        }
      }
      mutate {
        merge => {
          "event.idm.read_only_udm.security_result" => "security_result"
        }
      }
    }

    if [log_date] != "" {
      grok {
        match => {
          "log_date" => "(?P<date_log>%{MONTH:month} %{MONTHDAY:day} %{TIME:time} )%{WORD:timezone}"
        }
        overwrite => ["timezone"]
        on_error => "log_date_grok_fail"
      }
      if ![log_date_grok_fail] {
        # Compute Timezone Offset if it's loaded by KVData
    if [timezone] != "" {
        if [timezone] =~ ".*GMT.*" {
            mutate {
                gsub => ["timezone", "GMT", "+0000"]
            }
        }
        else if [timezone] == "Z" {
            mutate {
                gsub => ["timezone", "Z", "+0000"]
            }
        }
        else if [timezone] =~ ".*UTC.*" {
            mutate {
                gsub => ["timezone", "UTC", "+0000"]
            }
        }
        else if [timezone] == "Europe/Paris" {
            mutate {
                gsub => ["timezone", "Europe/Paris", "+0100"]
            }
        }
        else if [timezone] =~ ".*CET.*" {
            mutate {
                gsub => ["timezone", "CET", "+0100"]
            }
        }
        else if [timezone] =~ ".*CEST.*" {
            mutate {
                gsub => ["timezone", "CEST", "+0200"]
            }
        }
        else if [timezone] =~ ".*MET.*" {
            mutate {
                gsub => ["timezone", "MET", "+0100"]
            }
        }
        else if [timezone] =~ ".*DST.*" {
            mutate {
                gsub => ["timezone", "DST", "+0100"]
            }
        }
        else if [timezone] =~ ".*AEDT.*" {
            mutate {
                gsub => ["timezone", "AEDT", "+1100"]
            }
        }
        else if [timezone] =~ ".*EDT.*" {
            mutate {
                gsub => ["timezone", "EDT", "-0400"]
            }
        }
        else if [timezone] =~ ".*EST.*" {
            mutate {
                gsub => ["timezone", "EST", "-0500"]
            }
        }
        else if [timezone] =~ ".*CST.*" {
            mutate {
                gsub => ["timezone", "CST", "-0600"]
            }
        }
        else if [timezone] =~ ".*CDT.*" {
            mutate {
                gsub => ["timezone", "CDT", "-0500"]
            }
        }
        else if [timezone] =~ ".*MST.*" {
            mutate {
                gsub => ["timezone", "MST", "-0700"]
            }
        }
        else if [timezone] =~ ".*MDT.*" {
            mutate {
                gsub => ["timezone", "MDT", "-0600"]
            }
        }
        else if [timezone] =~ ".*PST.*" {
            mutate {
                gsub => ["timezone", "PST", "-0800"]
            }
        }
        else if [timezone] =~ ".*PDT.*" {
            mutate {
                gsub => ["timezone", "PDT", "-0700"]
            }
        }
        else if [timezone] =~ ".*HST.*" {
            mutate {
                gsub => ["timezone", "HST", "-1000"]
            }
        }
        else if [timezone] =~ ".*RST.*" {
            mutate {
                gsub => ["timezone", "RST", "+0100"]
            }
        }
        else if [timezone] =~ ".*IST.*" {
            mutate {
                gsub => ["timezone", "IST", "+0530"]
            }
        }
    }

        mutate {
          replace => {
            "date_log" => "%{date_log} %{timezone}"
          }
        }
        date {
          match => ["date_log", "MMM d HH:mm:ss.SSS Z"]
          rebase => true
        }
      }
    }

    if [cp] != "" {
      mutate {
        replace => {
          "cp_label.key" => "cp"
          "cp_label.value.string_value" => "%{cp}"
        }
      }
      mutate {
        merge => {
          "event.idm.read_only_udm.additional.fields" => "cp_label"
        }
      }
    }

    if [reqId] != "" {
      mutate {
        replace => {
          "event.idm.read_only_udm.metadata.product_log_id" => "%{reqId}"
        }
      }
    }

    if [rspContentType] not in ["","-"] {
      mutate {
        replace => {
          "event.idm.read_only_udm.target.file.mime_type" => "%{rspContentType}"
        }
      }
    }

    if [state] != "" {
      mutate {
        gsub => ["state","%[0-9]+",""]
      }
      mutate {
        replace => {
          "event.idm.read_only_udm.target.user.personal_address.state" => "%{state}"
        }
      }
    }

  if [version] != "" {
      mutate {
        replace => {
          "software_version.version" => "%{version}"
        }
      }
      mutate {
        merge => {
          "event.idm.read_only_udm.principal.asset.software" => "software_version"
        }
      }
    }
  }

  if [event][idm][read_only_udm][metadata][event_type] == "" {
    mutate {
      replace => {
        "event.idm.read_only_udm.metadata.event_type" => "GENERIC_EVENT"
      }
    }
  }
  mutate {
    merge => {
      "@output" => "event"
    }
  }
}
